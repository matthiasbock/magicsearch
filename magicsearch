#!/usr/bin/python
# -*- coding: iso-8859-15 -*-

##
## magicsearch is like the console utility "file"
## but it checks every block of a given file / block device
## and invokes a file-type specific recovery "recipe" to reconstruct files
##


# settings

blocksize = 512
maxcount = 50000			# 0 for infinite reading


# recipes

#import Exif, html, JFIF, m3u, PDF, RIFF, vCard, xml, ZIP
import MTS
import sys, os
recipes = {
#		'Exif.py':		Exif.identify,
#		'html.py':		html.identify,
#		'JFIF.py':		JFIF.identify,
#		'm3u.py':		m3u.identify,
#		'PDF.py':		PDF.identify,
#		'RIFF.py':		RIFF.identify,
#		'vCard.py':		vCard.identify,
#		'xml.py':		xml.identify,
#		'ZIP.py':		ZIP.identify
		'MTS.py':		MTS.identify
	}
path = os.path.dirname(__file__)


# console arguments

if len(sys.argv) < 2:
	print 'Usage: magicsearch /dev/sda1 0'
	sys.exit()
dev = sys.argv[1]
ipos = 0
if len(sys.argv) > 2:
	ipos = long(sys.argv[2])


# exit function

def exitfunction():
	log("stopped reading at ipos "+str(ipos))
sys.exitfunc = exitfunction


# main

from utils import *
from subprocess import Popen

log('Analyzing '+dev+', starting from ipos '+str(ipos)+' ...')
device = open(dev)
device.seek(ipos)
num = 0
block = device.read(blocksize)
while block and ((num < maxcount) or (maxcount == 0)):
	for recipe in recipes.keys():
		if recipes[recipe](block):
			position = str(ipos)+' ('+format(ipos)+')'
			print 'Hit @ '+position+': '+recipe
			cmd = path+'/'+recipe+' "'+dev+'" '+str(ipos)
			print cmd
			Popen(cmd, shell=True)	# invoke recovery recipe
#			log(position+': '+fileutil(dev, ipos))				# use "file" util to identify chunk
	ipos += blocksize
	num += 1
	block = device.read(blocksize)

